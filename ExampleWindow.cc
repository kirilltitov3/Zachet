#include <cmath>
static constexpr double Pi = acos(-1.);
#include "ExampleWindow.h"

ExampleWindow::ExampleWindow(int width, int height)
: Window(width, height)
{
	_angle = 0.;// Начальные параметры угла поворота
	_eye_level = 0.; // Начальные параметры высоты уровня глаз
}

static const float s_material_red[4]     { 1.f, 0.f, 0.f, 1.f }; //Задаются параметры цвета данной переменной
static const float s_material_green[4]   { 0.f, 1.f, 0.f, 1.f }; //Задаются параметры цвета данной переменной
static const float s_material_blue[4]    { 0.f, 0.f, 1.f, 1.f }; //Задаются параметры цвета данной переменной
static const float s_material_cyan[4]    { 0.f, 1.f, 1.f, 1.f }; //Задаются параметры цвета данной переменной
static const float s_material_magenta[4] { 1.f, 0.f, 1.f, 1.f }; //Задаются параметры цвета данной переменной
static const float s_material_yellow[4]  { 1.f, 1.f, 0.f, 1.f }; //Задаются параметры цвета данной переменной

void ExampleWindow::setup() // Здесь включается пустое окно и далее происходит его настройка
{
	glEnable(GL_DEPTH_TEST);// Здесь происходит включение буфера глубины, OpenGL будет автоматически сохранять значения глубины для всех прошедших тест фрагментов
	glEnable(GL_LIGHTING);// Здесь включается  расчет освещения
	glEnable(GL_LIGHT0);// Здесь происходи разблокировка источкника света 0
	glClearColor(0.15f, 0.15f, 0.4f, 1.0f); // Параметр состояния, который устанавливает значения цвета в буфер
	glMatrixMode(GL_PROJECTION);// Определение матрицы, над которой будут производиться операции
	gluPerspective(45., double(width()) / double(height()), 0.01, 20.0);// Создание проекции
	glMatrixMode(GL_MODELVIEW);// Задается матрица "активной камеры" (матрица модели + матрица вида), служит для отрисовки объемныъ объектов
}

void ExampleWindow::render()
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);// Очищает буферы, включенные в настоящее время для записи цвета и буфер глубины

	glLoadIdentity(); // Устанановка текущей матрицы в единичную. Сбрасывает все повороты/переносы/масштабирования/проекции в текущей матрице.
	gluLookAt(//Здесь выставляются параметры просмотра кубика, при их изменении кубик будет дальше-ближе, выше-ниже и т.д.
			5., 5., 5. * _eye_level,// вектор положения камеры по координатам x,y,z (положение точки глаза)
			0., 0., 0.,// вектор положения объекта по координатам x,y,z (положение опорной точки объекта)
			0., 0., 1.);//направление ветора "вверх" (up)

	glRotated(_angle, 0., 0., 1.);// производит поворот объекта против часовой стрелки на угол angle вокруг вектора (0,0,1)

	glBegin(GL_QUADS); // Это функция OpenGL. Определяется, что мы будем рисовать. (Квад)

	glNormal3d(  1.,  0.,  0.); // Задается нормаль с коордаинатами (1,0,0)
	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, s_material_red); //Задается материал: всей плоскости, цвет диффузного света, цвет из переменной  s_material_red
	glVertex3d(  1., -1.,  1.); // Параметры положения грани в пространстве, установка точек на плоскости, т.к. квад, то 4 штуки
	glVertex3d(  1.,  1.,  1.);
	glVertex3d(  1.,  1., -1.);
	glVertex3d(  1., -1., -1.);

	glNormal3d( -1.,  0.,  0.);
	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, s_material_cyan); //Задается материал: всей плоскости, цвет диффузного света, цвет из переменной s_material_cyan
	glVertex3d( -1.,  1.,  1.); // Параметры положения грани в пространстве, установка точек на плоскости, т.к. квад, то 4 штуки
	glVertex3d( -1., -1.,  1.);
	glVertex3d( -1., -1., -1.);
	glVertex3d( -1.,  1., -1.);

	glNormal3d(  0.,  1.,  0.);
	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, s_material_green);//Задается материал: всей плоскости, цвет диффузного света, цвет из переменной s_material_green
	glVertex3d( -1.,  1.,  1.); // Параметры положения грани в пространстве, установка точек на плоскости, т.к. квад, то 4 штуки
	glVertex3d(  1.,  1.,  1.);
	glVertex3d(  1.,  1., -1.);
	glVertex3d( -1.,  1., -1.);

	glNormal3d(  0., -1.,  0.);
	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, s_material_magenta);//Задается материал: всей плоскости, цвет диффузного света, цвет из переменной s_material_magenta
	glVertex3d(  1., -1.,  1.); // Параметры положения грани в пространстве, установка точек на плоскости, т.к. квад, то 4 штуки
	glVertex3d( -1., -1.,  1.);
	glVertex3d( -1., -1., -1.);
	glVertex3d(  1., -1., -1.);

	glNormal3d(  0.,  0.,  1.);
	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, s_material_blue);//Задается материал: всей плоскости, цвет диффузного света, цвет из переменной s_material_blue
	glVertex3d( -1.,  1.,  1.); // Параметры положения грани в пространстве, установка точек на плоскости, т.к. квад, то 4 штуки
	glVertex3d(  1.,  1.,  1.);
	glVertex3d(  1., -1.,  1.);
	glVertex3d( -1., -1.,  1.);

	glNormal3d(  0.,  0., -1.);
	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, s_material_yellow);//Задается материал: всей плоскости, цвет диффузного света, цвет из переменной s_material_yellow
	glVertex3d(  1.,  1., -1.); // Параметры положения грани в пространстве, установка точек на плоскости, т.к. квад, то 4 штуки
	glVertex3d( -1.,  1., -1.);
	glVertex3d( -1., -1., -1.);
	glVertex3d(  1., -1., -1.);



	glEnd();// Конец рисования Квада
}

void ExampleWindow::handle_logic()// Метод обработки логики, потомок Window
{
	//Скорость вращения кубика
	_angle += 1.;
	if (_angle >= 360.) // Здесь говориться что если скорость вращения кубика больше или равна 360,
		_angle -= 360.;// то мы вычитаем 360 и это будет скоростью.

	_eye_level = sin(_angle / 180. * Pi);//Здесь указывается на какой угол будет вращаться кубик
}
